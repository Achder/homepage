---
import SvgPlayground from '../layouts/SvgPlayground.astro'
import Button from '../components/Button.astro'
import Input from '../components/Input.astro'
import Slider from '../components/Slider.astro'
---

<SvgPlayground pageDescription="SVG sketching tool for generating downloadable abstract SVG forms" heading="Snizzle">
    <Fragment slot="controls">
        <Slider id="lerps" min={2} max={100} value={50} name="Lerps" />
        <div class="grid grid-cols-2 gap-2">
            <Button id="zoom-out">Zoom Out</Button>
            <Button id="zoom-in">Zoom In</Button>
        </div>
        <Input type="checkbox" id="show-handles" label="Show handles" checked="yes" />
    </Fragment>
</SvgPlayground>

<script>
    import { drawCircle } from '../svg/circle'
    import { drawPath, type Point } from '../svg/path'
    import { clear, initInteractiveSvg, type Size } from '../svg/svg'
    import { connect, connectChange, connectClick, get, getChecked, shiftLeft } from '../utils/controls'

    function add(a: Point, b: Point): Point {
        return {
            x: a.x + b.x,
            y: a.y + b.y,
        }
    }

    function resize(p: Point, length: number): Point {
        return {
            x: p.x * length,
            y: p.y * length,
        }
    }

    type PointGroup = {
        cpBack: Point
        point: Point
        cpFront: Point
    }

    function generatePoints(radius: number, numPoints: number, offset: Point) {
        const pointGroups: PointGroup[] = []
        const angleStep = (Math.PI * 2) / numPoints
        const arcLength = angleStep * radius

        for (let idx = 0; idx < numPoints; idx++) {
            const angle = angleStep * idx

            const point: Point = {
                x: radius * Math.cos(angle) + offset.x,
                y: radius * Math.sin(angle) + offset.y,
            }

            const tangent: Point = {
                x: -Math.sin(angle),
                y: Math.cos(angle),
            }

            const tangentBack = resize(tangent, -arcLength / 3)
            const tangentFront = resize(tangent, arcLength / 3)
            const cpBack = add(point, tangentBack)
            const cpFront = add(point, tangentFront)

            pointGroups.push({ cpBack, point, cpFront })
        }

        return pointGroups
    }

    function pathLerp(pointsA: Point[], pointsB: Point[], t: number) {
        if (pointsA.length !== pointsB.length) {
            throw new Error("Path sizes don't match. Can't lerp.")
        }

        return pointsA.map((a, idx) => {
            const b = pointsB[idx]
            return {
                x: a.x + (b.x - a.x) * t,
                y: a.y + (b.y - a.y) * t,
            }
        })
    }

    function addHandleToDom(container: HTMLElement, classId: string, point: Point) {
        const handle = document.createElement('div')
        handle.classList.add(
            classId,
            'rounded-full',
            'h-4',
            'w-4',
            'absolute',
            'translate-x-[-50%]',
            'translate-y-[-50%]'
        )
        handle.style.left = `${point.x}px`
        handle.style.top = `${point.y}px`

        handle.addEventListener('mousedown', (e) => {
            let offsetX = e.clientX - handle.offsetLeft
            let offsetY = e.clientY - handle.offsetTop

            function handleMouseMove(e: MouseEvent) {
                let newLeft = e.clientX - offsetX
                let newTop = e.clientY - offsetY

                handle.style.left = newLeft + 'px'
                handle.style.top = newTop + 'px'
            }

            function handleMouseUp() {
                document.removeEventListener('mousemove', handleMouseMove)
                document.removeEventListener('mouseup', handleMouseUp)
            }

            document.addEventListener('mousemove', handleMouseMove)
            document.addEventListener('mouseup', handleMouseUp)
        })

        container?.append(handle)

        return handle
    }

    function getPosition(element: HTMLDivElement): Point {
        return {
            x: element.offsetLeft,
            y: element.offsetTop,
        }
    }

    function handleCpControl(cp: HTMLDivElement, center: HTMLDivElement, counterCp: HTMLDivElement) {
        let mouseDownOnCp = false
        cp.addEventListener('mousedown', () => {
            mouseDownOnCp = true
        })

        cp.addEventListener('mouseup', () => {
            mouseDownOnCp = false
        })

        const observer = new MutationObserver(() => {
            if (!mouseDownOnCp) {
                return
            }

            const cpPos = getPosition(cp)
            const centerPos = getPosition(center)

            const reflectedX = -1 * (cpPos.x - centerPos.x)
            const reflectedY = -1 * (cpPos.y - centerPos.y)

            counterCp.style.left = `${centerPos.x + reflectedX}px`
            counterCp.style.top = `${centerPos.y + reflectedY}px`
        })

        observer.observe(cp, {
            attributes: true,
            attributeFilter: ['style'],
        })
    }

    function handleCenterControl(cpBack: HTMLDivElement, point: HTMLDivElement, cpFront: HTMLDivElement) {
        let cpBackOffset: Point | null = null
        let cpFrontOffset: Point | null = null

        point.addEventListener('mousedown', () => {
            const cpBackPos = getPosition(cpBack)
            const pointPos = getPosition(point)
            const cpFrontPos = getPosition(cpFront)

            cpBackOffset = {
                x: cpBackPos.x - pointPos.x,
                y: cpBackPos.y - pointPos.y,
            }

            cpFrontOffset = {
                x: cpFrontPos.x - pointPos.x,
                y: cpFrontPos.y - pointPos.y,
            }
        })

        point.addEventListener('mouseup', () => {
            cpBackOffset = null
            cpFrontOffset = null
        })

        const observer = new MutationObserver(() => {
            const pointPos = getPosition(point)

            if (cpBackOffset) {
                cpBack.style.left = `${pointPos.x + cpBackOffset.x}px`
                cpBack.style.top = `${pointPos.y + cpBackOffset.y}px`
            }

            if (cpFrontOffset) {
                cpFront.style.left = `${pointPos.x + cpFrontOffset.x}px`
                cpFront.style.top = `${pointPos.y + cpFrontOffset.y}px`
            }
        })

        observer.observe(point, {
            attributes: true,
            attributeFilter: ['style'],
        })
    }

    function addControlPoints(pointGroups: PointGroup[], classId: string) {
        for (const { cpBack, point, cpFront } of pointGroups) {
            const cpBackHandle = addHandleToDom(container, classId, cpBack)
            const pointHandle = addHandleToDom(container, classId, point)
            const cpFrontHandle = addHandleToDom(container, classId, cpFront)

            handleCpControl(cpBackHandle, pointHandle, cpFrontHandle)
            handleCpControl(cpFrontHandle, pointHandle, cpBackHandle)
            handleCenterControl(cpBackHandle, pointHandle, cpFrontHandle)
        }
    }

    function getPoints(classId: string, shift?: boolean): Point[] {
        const controlPoints = [...document.querySelectorAll<HTMLElement>(`.${classId}`)]
        const mapped = controlPoints.map((cp) => {
            return {
                x: cp.offsetLeft,
                y: cp.offsetTop,
            }
        })

        if (shift) {
            return shiftLeft(mapped)
        }

        return mapped
    }

    function scale(parentSize: Size, factor: number) {
        const center: Point = {
            x: parentSize.w / 2,
            y: parentSize.h / 2,
        }

        const controlPoints = [...document.querySelectorAll<HTMLElement>(`.pointA, .pointB, .pointC`)]
        for (const point of controlPoints) {
            point.style.left = `${center.x + (point.offsetLeft - center.x) * factor}px`
            point.style.top = `${center.y + (point.offsetTop - center.y) * factor}px`
        }
    }

    function onMove(callback: () => void) {
        const observer = new MutationObserver(() => {
            callback()
        })

        const cpA = document.querySelectorAll<HTMLElement>('.pointA')
        const cpB = document.querySelectorAll<HTMLElement>('.pointB')
        const cpC = document.querySelectorAll<HTMLElement>('.pointC')
        for (const cp of [...cpA, ...cpB, ...cpC]) {
            observer.observe(cp, {
                attributes: true,
                attributeFilter: ['style'],
            })
        }
    }

    const container = document.getElementById('container')!

    const init = (svg: HTMLElement, size: Size) => {
        addControlPoints(
            generatePoints(500, 4, {
                x: size.w / 2,
                y: size.h * 0.5,
            }),
            'pointA'
        )

        addControlPoints(
            generatePoints(300, 4, {
                x: size.w / 2,
                y: size.h * 0.5,
            }),
            'pointB'
        )

        addControlPoints(
            generatePoints(100, 4, {
                x: size.w / 2,
                y: size.h * 0.5,
            }),
            'pointC'
        )

        connect('lerps', () => render())
        connectClick('zoom-in', () => scale(size, 1.1))
        connectClick('zoom-out', () => scale(size, 0.9))
        connectChange('show-handles', () => render())

        const render = () => {
            clear(svg)

            const lerps = get<number>('lerps')
            const showHandles = getChecked('show-handles')

            const cpA = getPoints('pointA', true)
            const cpB = getPoints('pointB', true)
            const cpC = getPoints('pointC', true)

            for (let idx = 0; idx < lerps; idx++) {
                drawPath(svg, {
                    points: pathLerp(cpA, cpB, idx / lerps),
                    closed: true,
                    interpolation: 'bezier',
                    stroke: '#555',
                })
            }

            for (let idx = 0; idx < lerps; idx++) {
                drawPath(svg, {
                    points: pathLerp(cpB, cpC, idx / lerps),
                    closed: true,
                    interpolation: 'bezier',
                    stroke: '#555',
                })
            }

            if (showHandles) {
                drawPath(svg, {
                    points: cpA,
                    closed: true,
                    interpolation: 'bezier',
                    strokeWidth: 4,
                })

                drawPath(svg, {
                    points: cpB,
                    closed: true,
                    interpolation: 'bezier',
                    strokeWidth: 4,
                })

                drawPath(svg, {
                    points: cpC,
                    closed: true,
                    interpolation: 'bezier',
                    strokeWidth: 4,
                })

                const allPoints = [...getPoints('pointA'), ...getPoints('pointB'), ...getPoints('pointC')]
                for (let idx = 0; idx < allPoints.length; idx += 3) {
                    const cpBack = allPoints[idx]
                    const cpFront = allPoints[idx + 2]
                    drawPath(svg, {
                        points: [cpBack, cpFront],
                        stroke: '#00000033',
                        strokeWidth: 8,
                    })
                }
                for (const { x, y } of [...cpA, ...cpB, ...cpC]) {
                    drawCircle(svg, {
                        x,
                        y,
                        radius: 8,
                    })
                }
                for (const { x, y } of [...cpA, ...cpB, ...cpC]) {
                    drawCircle(svg, {
                        x,
                        y,
                        radius: 8,
                    })
                }
            }
        }

        onMove(render)
        render()
    }

    initInteractiveSvg({
        init,
    })
</script>
